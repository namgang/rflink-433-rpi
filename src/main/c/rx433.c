/*
 * rx433.c:
 *	Record events generated by a RF-link 433 MHz receiver.
 *      Listens for signals on one pin (see TESTPIN).
 *      Listens on another pin (now hardwired to 0) for control.
 *      The program stops when it detects a change on the control pin.
 *      If you are not fast enough the program stops after collecting
 *      8000 events in memory (see STORAGE).
 *      Typically you run this program to record a single keypress on a
 *      remote control.
 *
 *	How to test:
 *      Compile this program by linking the source code to the
 *      wiringPi examples directory. Then
 *              make rx433
 *	Run it (via sudo) with an output file name on the command line
 *              sudo ./rx433 <output file name>
 *	then in another terminal:
 *		gpio mode 0 up
 *		gpio mode 0 down
 *
 *      Before stopping the program writes the events to the output file.
 *      Output format: Each event generates one line containing a microsecond
 *      timestamp counting from some unknown staring point. Rising edges cause
 *      positive values, falling edges cause negated timestamps.
 *
 * Copyright (c) 2018 Hakan Soderstrom, Soderstrom Programvaruverkstad AB,
 * Stockholm, Sweden, subject to the same terms and conditions as wiringPi.
 ***********************************************************************
 *    wiringPi is free software: you can redistribute it and/or modify
 *    it under the terms of the GNU Lesser General Public License as published by
 *    the Free Software Foundation, either version 3 of the License, or
 *    (at your option) any later version.
 *
 *    wiringPi is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *    GNU Lesser General Public License for more details.
 *
 *    You should have received a copy of the GNU Lesser General Public License
 *    along with wiringPi.  If not, see <http://www.gnu.org/licenses/>.
 ***********************************************************************
 */

#include <stdio.h>
#include <string.h>
#include <errno.h>
#include <stdlib.h>
#include <wiringPi.h>

#define STORAGE 8000
#define TESTPIN 5

/* globalCounter:
 *	Global variable collecting interrupt events.
 *	Must be declared volatile to make sure the compiler doesn't cache it.
 */

static volatile int globalCounter[STORAGE];
static volatile int globalIdx;
static volatile int running;


/*
 * myInterrupt:
 *********************************************************************************
 */

void ctlInterrupt (void) { running = 0; }
void signalInterrupt (void) {
  int sig;
  int us;

  if (globalIdx >= STORAGE) {
    running = 0;
  } else {
    sig = digitalRead(TESTPIN);
    us = micros();
    globalCounter[globalIdx++] = (sig > 0)? us : -us;
  }
}


/*
 *********************************************************************************
 * main
 *********************************************************************************
 */

int main (int argc, char** argv)
{
  int idx;
  running = 1;
  FILE* fp;
  
  if (argc < 2) {
    printf("%s: output file name required. Exiting...\n", argv[0]);
    exit(1);
  } else {
    fp = fopen(argv[1], "w");
  }

  for (idx = 0; idx < STORAGE; idx++) {
    globalCounter[idx] = 0;
  }

  wiringPiSetup () ;
  wiringPiISR (0, INT_EDGE_BOTH, &ctlInterrupt) ;
  wiringPiISR (TESTPIN, INT_EDGE_BOTH, &signalInterrupt) ;

  globalIdx = 0;
  globalCounter[globalIdx++] = micros();
  printf("Listening...\n");

  while (running)
  {
    delay(500);
  }

  for (idx = 0; idx < STORAGE; idx++) {
    int value = globalCounter[idx];
    fprintf(fp, "%8d\n", value);
    if (idx > 10 && value == 0) idx = STORAGE;
  }

  fclose(fp);
  return 0 ;
}
