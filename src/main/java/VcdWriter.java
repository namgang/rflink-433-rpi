import java.io.*;

import java.util.ArrayList;
import java.util.Date;
import java.util.List;

/**
 * Utility processing the output from a RF-link 433 MHz receiver.
 * There are methods for reading and writing files in various formats.
 */
public class VcdWriter {
    /** File name extension for CSV data. */
    public static final String CSV_EXT = ".csv";

    /** File name extension for pulse data. */
    public static final String PULSE_EXT = ".pulse";

    /** File name extension for raw data. */
    public static final String RAW_EXT = ".raw";

    /** File name extension for VCD files. */
    public static final String VCD_EXT = ".vcd";

    /** Directory separator. */
    public static final String DIR_SEP = File.separator;

    /** Signal change data. */
    protected final List<Edge> data;
    
    /**
     * Construct from signal data.
     */
    public VcdWriter(List<Edge> data) {
	this.data = data;
    }

    /**
     * The main program takes a directory name.
     * It processes all *.raw files in that directory, writing the
     * corresponding *.vcd and *.pulse files to the same directory.
     */
    public static void main(String[] args) {
	if (args.length == 0) {
	    System.out.println("Directory name required");
	} else {
	    File dir = new File(args[0]);
	    if (!dir.isDirectory()) {
		System.out.println("Directory name expected, got " + dir.getName());
		System.exit(1);
	    }

	    // Get all .raw files.
	    String[] rawFilenames = dir.list(new FilenameFilter() {
		    @Override
		    public boolean accept(File otherDir, String otherName) {
			return otherDir.equals(dir) && otherName.lastIndexOf(RAW_EXT) > 0;
		    }
		});

	    final String dirName = dir.getName();
	    for (String fileName : rawFilenames) {
		int idx = fileName.lastIndexOf(RAW_EXT);
		String rootName = dirName + DIR_SEP + fileName.substring(0, idx);
		System.out.println("--- Now processing [" + rootName + "]");
		try {
		    VcdWriter writer = VcdWriter.ofRaw(rootName);
		    writer.writeVcd(rootName);
		    writer.writePulse(rootName);
		} catch (IOException exc) {
		    System.out.println("EXCEPTION: " + exc.getMessage());
		}
	    }
	}
    }

    /**
     * Create a writer from a CSV file.
     * Expected format: three integers separated by semicolon and
     * optional white space. The integers are,
     * (1) Time stamp in microseconds from some arbitrary starting point,
     * (2) microseconds since the previous event,
     * (3) the signal, 1 for a rising edge, 0 for a falling edge.
     * @param fileName must be the name of the input file minus
     * extension ".csv" which is added by the method,
     * @return a writer containing all data from the input file.
     */
    public static VcdWriter ofCsv(String fileName) throws IOException {
	List<Edge> list = new ArrayList<Edge>();
	String line = null;
	try (FileReader fr = new FileReader(fileName + CSV_EXT);
	     BufferedReader br = new BufferedReader(fr))
	    {
		while ((line = br.readLine()) != null) {
		    String[] pieces = line.split(";");
		    Long time = Long.parseLong(pieces[0].trim());
		    Integer signal = Integer.parseInt(pieces[2].trim());
		    list.add(new Edge(time, signal));
		}
	    }

	return new VcdWriter(list);
    }

    /**
     * Create a writer from a "raw" text file containing signed timings.
     * This is the format generated by the rx433.c program.
     * The time unit must be micros.
     * @param fileName must be the name of the input file minus
     * extension ".raw" which is added by the method,
     * @return a writer containing all data from the input file.
     */
    public static VcdWriter ofRaw(String fileName) throws IOException {
	List<Edge> list = new ArrayList<Edge>();
	String line = null;
	try (FileReader fr = new FileReader(fileName + RAW_EXT);
	     BufferedReader br = new BufferedReader(fr))
	    {
		while ((line = br.readLine()) != null) {
		    Integer signedTime = Integer.parseInt(line.trim());
		    Integer absTime = Math.abs(signedTime);
		    Integer signal = (signedTime >= 0)? 1 : 0;
		    list.add(new Edge(absTime.longValue(), signal));
		}
	    }

	return new VcdWriter(list);
    }

    /**
     * Get one reading from the input data.
     * @param idx must be the zero-based index of the reading,
     * @return an Edge instance containing event data.
     */
    public Edge getEdge(int idx) {
	return data.get(idx);
    }

    /**
     * @return the number of events in input data.
     */
    public int size() {
	return data.size();
    }

    /**
     * Write data to a pulse file.
     * This is a homegrown format somewhat useful for humans.
     * Each line contains a timestamp, the length of the high value,
     * the length of the following low value, all in microseconds.
     * The values are separated by semicolon.
     * If the first edge is falling then this edge is ignored.
     * @param fileName must be the name of the output file minus
     * extension ".pulse" which is added by the method.
     */
    public void writePulse(String fileName) throws IOException {
	try (FileWriter fw = new FileWriter(fileName + PULSE_EXT);
	     PrintWriter pw = new PrintWriter(fw))
	    {
		doWritePulse(pw);
		pw.flush();
	    }
    }

    private void doWritePulse(PrintWriter pw) throws IOException {
	int idx = 0;
	// Trying to make indexing as obvious as possible.
	while (idx < size()) {
	    // For some reason there may be multiple edges in the same direction.
	    // Like several consecutive falling edges.
	    idx = nextEdge(idx, 1);
	    if (idx < 0) break;
	    Edge firstEdge = data.get(idx);
	    idx = nextEdge(idx, 0);
	    if (idx < 0) break;
	    Edge secondEdge = data.get(idx);
	    idx = nextEdge(idx, 1);
	    if (idx < 0) break;
	    Edge thirdEdge = data.get(idx);

	    long highDuration = secondEdge.timeMicros - firstEdge.timeMicros;
	    long lowDuration = thirdEdge.timeMicros - secondEdge.timeMicros;
	    pw.println(String.format("%8d; %5d; %5d", firstEdge.timeMicros,
				     highDuration, lowDuration));
	}
    }

    /**
     * Find the next edge with a given value.
     * @param fromIdx must be the index to start from,
     * @param value must be the signal value to look for,
     * @return the index of the next edge satisfying the condition
     * (could be fromIdx), or -1 no such edge exists.
     */
    private int nextEdge(int fromIdx, int value) {
	int idx = fromIdx;
	Edge edge = data.get(idx);
	while (edge.signal != value && idx + 1 < size()) {
	    edge = data.get(++idx);
	}

	return (edge.signal == value)? idx : -1;
    }

    /**
     * Write data to a VCD file.
     * The VCD file format can be read by many software oscilloscopes
     * like GtkWave.
     * @param fileName must be the name of the output file minus
     * extension ".vcd" which is added by the method.
     */
    public void writeVcd(String fileName) throws IOException {
	try (FileWriter fw = new FileWriter(fileName + VCD_EXT);
	     PrintWriter pw = new PrintWriter(fw))
	    {
		writeVcdHeader(pw);
		writeVcdBulk(pw);
	    }
    }

    private void writeVcdBulk(PrintWriter pw) throws IOException {
	for (Edge edge : data) {
	    pw.println("#" + edge.timeMicros);
	    pw.println(edge.signal + "S");
	}

	pw.flush();
    }

    private void writeVcdHeader(PrintWriter pw) throws IOException {
	pw.println("$version Generated by VcdWriter $end");
	pw.println("$date " + new Date());
	pw.println("$end");
	pw.println("$timescale 1 us $end");

	pw.println("$scope module TOP $end");
	pw.println("$var wire 1 S rx $end");
	pw.println("$upscope $end");
	pw.println("$enddefinitions $end");
	pw.println("$dumpvars");
	pw.println("0S");
	pw.println("$end");
    }
}
